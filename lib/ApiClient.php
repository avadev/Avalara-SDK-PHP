<?php
/**
 * ApiClient.php
 * PHP version 7.3
 *
 * @category Class
 * @package  Avalara\SDK
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Avalara Shipping Verification for Beverage Alcohol
 *
 * API for evaluating transactions against direct-to-consumer Beverage Alcohol shipping regulations.  This API is currently in beta.
 *
 * The version of the OpenAPI document: 2.1.0-beta
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.3.1
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Avalara\SDK;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Avalara\SDK\ApiException;
use Avalara\SDK\Configuration;
use Avalara\SDK\HeaderSelector;
use Avalara\SDK\ObjectSerializer;
use Avalara\SDK\TokenMetadata;
use Avalara\SDK\Utils\BaseLogger;
use Ds\Map;
use Psr\Log\LoggerInterface;

/**
 * ApiClient Class Doc Comment
 *
 * @category Class
 * @package  Avalara\SDK
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class ApiClient
{
    /**
     * @var GuzzleHttp\Client
     */
    public $client;

    /**
     * @var string
     */
    public $sdkVersion;

    /**
     * @var Configuration
     */
    public $config;

    /**
     * @var HeaderSelector
     */
    public $headerSelector;

    /**
     * @var Map
     */
    public $accessTokenMap;

    /**
     * @var LoggerInterface The logger instance which is intended to be used for logging puposes      
     */
    public $logger = null;

    /**
     * @var bool        The setting for whether the request and response body should be logged or not
     */
    public $logRequestAndResponse;
    
    /**
     * @param Configuration   $config
     */
    public function __construct(
        Configuration $config = null
    ) {

        if (is_null($config)){
            throw new ApiException("Configuration is not set or null");
        }

        $this->accessTokenMap = new \Ds\Map();

        $this->config = $config;
        $this->environment = $this->config->getEnvironment();
        
        // Environment validation only - URL setting is now handled by microservice-aware getBasePath method
        if(strtolower($this->environment)=="test"){
            if (is_null($this->config->getTestBasePath())) {
                throw new ApiException("TestBasePath must be passed into the config object when environment=\"test\".");
            }
        }
        elseif(!in_array(strtolower($this->environment), ['sandbox', 'qa', 'production', 'dev'])){
            throw new ApiException("Environment is not set correctly.");
        }

        $logOptions = $this->config->getLogOptions();
        if ($logOptions != null && $logOptions->logger != null) {
            $this->logger = $logOptions->logger;
        } else {
            $this->logger = new BaseLogger();
        }
        
        $this->logRequestAndResponse = $logOptions->logRequestAndResponse;

        $this->client = $this->config->getClient();
                
        $this->headerSelector =  new HeaderSelector();
    }

    /**
     * Sets the sdkVersion
     *
     * @param string $sdkVersion 
     *
     * @return $this
     */
    public function setSdkVersion($sdkVersion)
    {
        $this->sdkVersion = $sdkVersion;
        return $this;
    }

    /**
     * Adds appropriate Authentication header to the array of headers passed in
     *
     * @param Array $headers 
     *
     * @return $headers
     */
    public function applyAuthToRequest($headers, $requiredScopes) {
        $bearerToken = $this->config->getBearerToken();
        $clientId = $this->config->getClientId();
        $clientSecret = $this->config->getClientSecret();
        $username = $this->config->getUserName();
        $password = $this->config->getPassword();

        if (!is_null($bearerToken)) {
            $headers['Authorization'] = 'Bearer ' . $bearerToken;
        } elseif (!is_null($clientId) && !is_null($clientSecret)) {
            $scopes = $this->standardizeScopes($requiredScopes);
            $accessToken = $this->getOAuthAccessToken($scopes);
            if (is_null($accessToken)) {
                $this->updateOAuthAccessToken($scopes, null);
                $accessToken = $this->getOAuthAccessToken($scopes);
            }
            $headers['Authorization'] = 'Bearer ' . $accessToken;
        } elseif (!is_null($username) && !is_null($password)) {
            $headers['Authorization'] = 'Basic ' . base64_encode($username . ":" . $password);
        }
        return $headers;
    }

    private function standardizeScopes($requiredScopes) {
        $strArray = explode(' ', $requiredScopes);
        sort($strArray);
        return implode(' ', $strArray);
    }

    private function getOAuthAccessToken($scopes) {
        $tokenMetadata = null;
        if ($this->accessTokenMap->hasKey($scopes)) {
            $tokenMetadata = $this->accessTokenMap->get($scopes);
        }
        if (!is_null($tokenMetadata)) {
            $accessToken = $tokenMetadata->accessToken;
            $expiry = $tokenMetadata->expiry;
            $expirationTime = time() + 300;
            if ($expirationTime < $expiry) {
                return $accessToken;
            }
        }
        return null;
    }

    private function updateOAuthAccessToken($scopes, $accessToken) {
        $currentAccessToken = $this->getOAuthAccessToken($scopes);
        if (is_null($currentAccessToken) || $currentAccessToken == $accessToken) {
            try {
                $data = $this->buildOAuthRequest($scopes);
                $timestamp = time() + $data->expires_in;
                $tokenMetadata = new TokenMetadata($data->access_token, $timestamp);
                $this->accessTokenMap->put($scopes, $tokenMetadata);
            } catch (Exception $e) {
                echo 'OAuth2 Token retrieval failed. Error: ',  $e->getMessage(), "\n";
                throw new ApiException('OAuth2 Token retrieval failed. Error: '.  $e->getMessage());
            }
        }
    }

    private function buildOAuthRequest($scopes) {
        $this->config->setOAuthEndpoints();
        $httpBody = 'grant_type=client_credentials&scope=' . $scopes;
        $headers = [];
        $headers['Content-Type'] = 'application/x-www-form-urlencoded';
        $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getClientId() . ":" . $this->config->getClientSecret());
        $headers['Accept'] = 'application/json';
        $request = new Request('POST', $this->config->getTokenUrl(), $headers, $httpBody);
        $response = $this->send_sync($request, []);
        $content = (string) $response->getBody();
        return json_decode($content);
    }

    public function refreshAuthToken($headers, $requiredScopes) {
        $authHeader = $headers['Authorization'][0];
        $authValues = explode(' ', $authHeader);
        if (!is_null($authValues) && count($authValues) == 2 && 
            !is_null($this->config->getClientId()) && !is_null($this->config->getClientSecret())) {
            
            $this->updateOAuthAccessToken($requiredScopes, $authValues[1]);
        }
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }
       
    /**
     * Operation send_sync
     *
     * Executes http request synchronously
     *
     * @param  GuzzleHttp\Request
     * @param array of http client options
     * @param  \returnType
     * @throws \Avalara\SDK\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return Http response
     */
    public function send_sync($request, $options)
    {
        return $this->client->send($request, $options);
    }

     /**
     * Operation send_async
     *
     * Executes http request synchronously
     *
     * @param  GuzzleHttp\Request
     * @param array of http client options
     * @param  \returnType
     * @throws \Avalara\SDK\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return Http response
     */
    public function send_async($request, $options)
    {
        return $this->client->sendAsync($request, $options);
    }
}
